// Internal Database Schema for Offline Functionality
// This provides local storage when external systems (Sage 300, sp.vumatel.co.za, Sage X3) are down

export interface InternalJobRecord {
  id: string;
  externalTicketId?: string;
  workOrderNumber: string;
  title: string;
  description: string;
  type: "Installation" | "Maintenance" | "Repair" | "Inspection" | "Emergency";
  priority: "Low" | "Medium" | "High" | "Critical";
  status: "Open" | "In Progress" | "Pending" | "Resolved" | "Closed";
  assignedTechnician: string;
  assistantTechnician?: string;

  // Client Information
  client: {
    name: string;
    address: string;
    coordinates?: {
      lat: number;
      lng: number;
    };
    contactPerson: string;
    phone: string;
    email?: string;
  };

  // Time Tracking
  clockInTime?: string;
  clockOutTime?: string;
  workingHours: number;
  distanceTraveled: number;
  pausedTime?: number;
  estimatedHours: number;
  actualHours?: number;

  // Progress Tracking
  scheduledDate: string;
  startedDate?: string;
  completedDate?: string;
  nearClientDetected?: boolean;
  autoTrackingStarted?: boolean;

  // Documentation
  photos: {
    category:
      | "before-light-levels"
      | "fault-before-fix"
      | "fault-after-fix"
      | "after-light-levels";
    url: string;
    timestamp: string;
    description?: string;
  }[];

  notes: string;
  signOffComments?: string;
  customerSignature?: string;
  technicianSignature?: string;

  // Sync Status
  syncStatus: "pending" | "synced" | "failed";
  syncAttempts: number;
  lastSyncAttempt?: string;
  createdOffline: boolean;
  lastModified: string;
}

export interface InternalStockUsage {
  id: string;
  jobId: string;
  workOrderNumber: string;
  itemCode: string;
  description: string;
  quantityUsed: number;
  unitCost?: number;
  totalCost?: number;
  container: string;
  timestamp: string;
  technician: string;
  comments?: string;

  // External system reference
  externalMovementId?: string;
  syncStatus: "pending" | "synced" | "failed";
  syncAttempts: number;
  lastSyncAttempt?: string;
}

export interface InternalStockAllocation {
  id: string;
  jobId: string;
  workOrderNumber: string;
  itemCode: string;
  description: string;
  quantityAllocated: number;
  quantityRemaining: number;
  container: string;
  allocatedDate: string;
  technician: string;

  // Sync Status
  syncStatus: "pending" | "synced" | "failed";
  syncAttempts: number;
  lastSyncAttempt?: string;
}

export interface InternalClockRecord {
  id: string;
  technician: string;
  date: string; // YYYY-MM-DD format
  clockIns: Array<{
    clockIn: string;
    clockOut?: string;
    workingHours?: number;
    distanceTraveled?: number;
    jobId?: string;
    workOrderNumber?: string;
    location?: {
      lat: number;
      lng: number;
    };
  }>;
  totalWorkingHours: number;
  totalDistance: number;
  dailyFeedback?: {
    rating: number;
    feedback: string;
    timestamp: string;
  };

  // Overtime Claims
  overtimeClaims: Array<{
    id: string;
    workOrderNumber: string;
    reason: string;
    hours: number;
    rate: number;
    autoGenerated: boolean;
    timestamp: string;
    status: "pending" | "approved" | "rejected";
  }>;

  // Sync Status
  syncStatus: "pending" | "synced" | "failed";
  syncAttempts: number;
  lastSyncAttempt?: string;
}

export interface InternalSafetyCheck {
  id: string;
  technician: string;
  checklistType:
    | "harness"
    | "fire-extinguisher"
    | "first-aid"
    | "electrical-tools"
    | "working-heights"
    | "risk-assessment"
    | "fiber-equipment";
  checklistTitle: string;
  items: Array<{
    id: string;
    item: string;
    checked: boolean;
    required: boolean;
    notes?: string;
    image?: string;
    serialNumber?: string;
    expiryDate?: string;
  }>;
  globalSerialNumber?: string;
  globalExpiryDate?: string;
  locationImage?: string;
  completedDate: string;
  status: "pending" | "in-progress" | "completed";

  // Sync Status
  syncStatus: "pending" | "synced" | "failed";
  syncAttempts: number;
  lastSyncAttempt?: string;
}

export interface InternalIncidentReport {
  id: string;
  technician: string;
  incidentType: string;
  severityLevel: string;
  dateTime: string;
  location: string;
  coordinates?: string;
  weatherConditions?: string;
  description: string;

  // Police and Emergency Services
  policeCalled: boolean;
  policeReferenceNumber?: string;
  attendingOfficer?: string;
  policeStation?: string;
  ambulanceCalled: boolean;
  fireServiceCalled: boolean;

  // Third Party Information
  thirdParty?: {
    name: string;
    contactNumber: string;
    address: string;
    licenseNumber?: string;
    vehicleRegistration?: string;
    insuranceCompany?: string;
    insurancePolicyNumber?: string;
    statement?: string;
  };

  // People Involved
  injuredPersons?: string;
  witnesses?: string;

  // Damage Assessment
  vehicleDamage?: string;
  thirdPartyDamage?: string;
  immediateActions?: string;

  // Additional Information
  contributingFactors?: string;
  vehicleSpeed?: number;
  speedLimit?: number;
  additionalComments?: string;

  photos: string[];

  // Sync Status
  syncStatus: "pending" | "synced" | "failed";
  syncAttempts: number;
  lastSyncAttempt?: string;
  timestamp: string;
}

export interface InternalNetworkAssessment {
  id: string;
  technician: string;
  networkAreaType: string;
  networkTechnologyType: string;
  location: string;
  coordinates?: string;
  equipmentLabel: string;
  testType: string;

  // Test Results
  signalStrength?: number;
  downloadSpeed?: number;
  uploadSpeed?: number;
  latency?: number;
  packetLoss?: number;

  // Issues and Recommendations
  priority: "low" | "medium" | "high" | "critical";
  issuesFound: string;
  recommendedActions: string;

  images: string[];
  timestamp: string;

  // Sync Status
  syncStatus: "pending" | "synced" | "failed";
  syncAttempts: number;
  lastSyncAttempt?: string;
}

// Internal Database Service for Offline Operations
export class InternalDatabaseService {
  private static instance: InternalDatabaseService;
  private dbName = "BritelinkFieldApp";
  private dbVersion = 1;
  private db: IDBDatabase | null = null;

  private constructor() {
    // Only initialize database in browser environment
    if (typeof indexedDB !== "undefined") {
      this.initDatabase();
    }
  }

  static getInstance(): InternalDatabaseService {
    if (!InternalDatabaseService.instance) {
      InternalDatabaseService.instance = new InternalDatabaseService();
    }
    return InternalDatabaseService.instance;
  }

  private async initDatabase(): Promise<void> {
    // Check if we're in a browser environment
    if (typeof indexedDB === "undefined") {
      console.warn("IndexedDB not available in this environment");
      return;
    }

    return new Promise((resolve, reject) => {
      const request = indexedDB.open(this.dbName, this.dbVersion);

      request.onerror = () => reject(request.error);
      request.onsuccess = () => {
        this.db = request.result;
        resolve();
      };

      request.onupgradeneeded = (event) => {
        const db = (event.target as IDBOpenDBRequest).result;

        // Create object stores
        if (!db.objectStoreNames.contains("jobs")) {
          const jobStore = db.createObjectStore("jobs", { keyPath: "id" });
          jobStore.createIndex("status", "status", { unique: false });
          jobStore.createIndex("technician", "assignedTechnician", {
            unique: false,
          });
          jobStore.createIndex("syncStatus", "syncStatus", { unique: false });
        }

        if (!db.objectStoreNames.contains("stockUsage")) {
          const stockStore = db.createObjectStore("stockUsage", {
            keyPath: "id",
          });
          stockStore.createIndex("jobId", "jobId", { unique: false });
          stockStore.createIndex("syncStatus", "syncStatus", { unique: false });
        }

        if (!db.objectStoreNames.contains("stockAllocations")) {
          const allocStore = db.createObjectStore("stockAllocations", {
            keyPath: "id",
          });
          allocStore.createIndex("jobId", "jobId", { unique: false });
          allocStore.createIndex("syncStatus", "syncStatus", { unique: false });
        }

        if (!db.objectStoreNames.contains("clockRecords")) {
          const clockStore = db.createObjectStore("clockRecords", {
            keyPath: "id",
          });
          clockStore.createIndex("technician", "technician", { unique: false });
          clockStore.createIndex("date", "date", { unique: false });
          clockStore.createIndex("syncStatus", "syncStatus", { unique: false });
        }

        if (!db.objectStoreNames.contains("safetyChecks")) {
          const safetyStore = db.createObjectStore("safetyChecks", {
            keyPath: "id",
          });
          safetyStore.createIndex("technician", "technician", {
            unique: false,
          });
          safetyStore.createIndex("checklistType", "checklistType", {
            unique: false,
          });
          safetyStore.createIndex("syncStatus", "syncStatus", {
            unique: false,
          });
        }

        if (!db.objectStoreNames.contains("incidentReports")) {
          const incidentStore = db.createObjectStore("incidentReports", {
            keyPath: "id",
          });
          incidentStore.createIndex("technician", "technician", {
            unique: false,
          });
          incidentStore.createIndex("syncStatus", "syncStatus", {
            unique: false,
          });
        }

        if (!db.objectStoreNames.contains("networkAssessments")) {
          const networkStore = db.createObjectStore("networkAssessments", {
            keyPath: "id",
          });
          networkStore.createIndex("technician", "technician", {
            unique: false,
          });
          networkStore.createIndex("syncStatus", "syncStatus", {
            unique: false,
          });
        }
      };
    });
  }

  private checkDatabaseAvailable(): boolean {
    if (!this.db) {
      console.warn("Database not available in this environment");
      return false;
    }
    return true;
  }

  // Job Management
  async saveJob(job: InternalJobRecord): Promise<void> {
    if (!this.db) {
      console.warn("Database not available, skipping save operation");
      return;
    }
    const transaction = this.db.transaction(["jobs"], "readwrite");
    const store = transaction.objectStore("jobs");
    await store.put(job);
  }

  async getJob(id: string): Promise<InternalJobRecord | null> {
    if (!this.db) {
      console.warn("Database not available, returning null");
      return null;
    }
    const transaction = this.db.transaction(["jobs"], "readonly");
    const store = transaction.objectStore("jobs");
    const result = await store.get(id);
    return result || null;
  }

  async getJobsByTechnician(technician: string): Promise<InternalJobRecord[]> {
    if (!this.checkDatabaseAvailable()) return [];
    const transaction = this.db!.transaction(["jobs"], "readonly");
    const store = transaction.objectStore("jobs");
    const index = store.index("technician");
    const result = await index.getAll(technician);
    return result || [];
  }

  async getJobsToSync(): Promise<InternalJobRecord[]> {
    if (!this.checkDatabaseAvailable()) return [];
    const transaction = this.db!.transaction(["jobs"], "readonly");
    const store = transaction.objectStore("jobs");
    const index = store.index("syncStatus");
    const result = await index.getAll("pending");
    return result || [];
  }

  // Stock Management
  async saveStockUsage(usage: InternalStockUsage): Promise<void> {
    if (!this.checkDatabaseAvailable()) return;
    const transaction = this.db!.transaction(["stockUsage"], "readwrite");
    const store = transaction.objectStore("stockUsage");
    await store.put(usage);
  }

  async getStockUsageByJob(jobId: string): Promise<InternalStockUsage[]> {
    if (!this.checkDatabaseAvailable()) return [];
    const transaction = this.db!.transaction(["stockUsage"], "readonly");
    const store = transaction.objectStore("stockUsage");
    const index = store.index("jobId");
    const result = await index.getAll(jobId);
    return result || [];
  }

  async saveStockAllocation(
    allocation: InternalStockAllocation,
  ): Promise<void> {
    if (!this.checkDatabaseAvailable()) return;
    const transaction = this.db!.transaction(["stockAllocations"], "readwrite");
    const store = transaction.objectStore("stockAllocations");
    await store.put(allocation);
  }

  // Clock Records
  async saveClockRecord(record: InternalClockRecord): Promise<void> {
    if (!this.checkDatabaseAvailable()) return;
    const transaction = this.db!.transaction(["clockRecords"], "readwrite");
    const store = transaction.objectStore("clockRecords");
    await store.put(record);
  }

  async getClockRecord(
    technician: string,
    date: string,
  ): Promise<InternalClockRecord | null> {
    if (!this.checkDatabaseAvailable()) return null;
    const transaction = this.db!.transaction(["clockRecords"], "readonly");
    const store = transaction.objectStore("clockRecords");
    const id = `${technician}-${date}`;
    const result = await store.get(id);
    return result || null;
  }

  // Safety Checks
  async saveSafetyCheck(check: InternalSafetyCheck): Promise<void> {
    if (!this.checkDatabaseAvailable()) return;
    const transaction = this.db!.transaction(["safetyChecks"], "readwrite");
    const store = transaction.objectStore("safetyChecks");
    await store.put(check);
  }

  async getSafetyChecksByTechnician(
    technician: string,
  ): Promise<InternalSafetyCheck[]> {
    if (!this.checkDatabaseAvailable()) return [];
    const transaction = this.db!.transaction(["safetyChecks"], "readonly");
    const store = transaction.objectStore("safetyChecks");
    const index = store.index("technician");
    const result = await index.getAll(technician);
    return result || [];
  }

  // Incident Reports
  async saveIncidentReport(report: InternalIncidentReport): Promise<void> {
    if (!this.checkDatabaseAvailable()) return;
    const transaction = this.db!.transaction(["incidentReports"], "readwrite");
    const store = transaction.objectStore("incidentReports");
    await store.put(report);
  }

  // Network Assessments
  async saveNetworkAssessment(
    assessment: InternalNetworkAssessment,
  ): Promise<void> {
    if (!this.checkDatabaseAvailable()) return;
    const transaction = this.db!.transaction(
      ["networkAssessments"],
      "readwrite",
    );
    const store = transaction.objectStore("networkAssessments");
    await store.put(assessment);
  }

  // Sync Management
  async getAllPendingSync(): Promise<{
    jobs: InternalJobRecord[];
    stockUsage: InternalStockUsage[];
    stockAllocations: InternalStockAllocation[];
    clockRecords: InternalClockRecord[];
    safetyChecks: InternalSafetyCheck[];
    incidentReports: InternalIncidentReport[];
    networkAssessments: InternalNetworkAssessment[];
  }> {
    if (!this.checkDatabaseAvailable()) {
      return {
        jobs: [],
        stockUsage: [],
        stockAllocations: [],
        clockRecords: [],
        safetyChecks: [],
        incidentReports: [],
        networkAssessments: [],
      };
    }

    const [
      jobs,
      stockUsage,
      stockAllocations,
      clockRecords,
      safetyChecks,
      incidentReports,
      networkAssessments,
    ] = await Promise.all([
      this.getItemsByIndex("jobs", "syncStatus", "pending"),
      this.getItemsByIndex("stockUsage", "syncStatus", "pending"),
      this.getItemsByIndex("stockAllocations", "syncStatus", "pending"),
      this.getItemsByIndex("clockRecords", "syncStatus", "pending"),
      this.getItemsByIndex("safetyChecks", "syncStatus", "pending"),
      this.getItemsByIndex("incidentReports", "syncStatus", "pending"),
      this.getItemsByIndex("networkAssessments", "syncStatus", "pending"),
    ]);

    return {
      jobs,
      stockUsage,
      stockAllocations,
      clockRecords,
      safetyChecks,
      incidentReports,
      networkAssessments,
    };
  }

  private async getItemsByIndex(
    storeName: string,
    indexName: string,
    value: any,
  ): Promise<any[]> {
    if (!this.checkDatabaseAvailable()) return [];
    const transaction = this.db!.transaction([storeName], "readonly");
    const store = transaction.objectStore(storeName);
    const index = store.index(indexName);
    const result = await index.getAll(value);
    return result || [];
  }

  // Update sync status
  async updateSyncStatus(
    storeName: string,
    id: string,
    status: "synced" | "failed",
    attempts: number,
  ): Promise<void> {
    if (!this.checkDatabaseAvailable()) return;
    const transaction = this.db!.transaction([storeName], "readwrite");
    const store = transaction.objectStore(storeName);
    const item = await store.get(id);

    if (item) {
      item.syncStatus = status;
      item.syncAttempts = attempts;
      item.lastSyncAttempt = new Date().toISOString();
      await store.put(item);
    }
  }

  // Clear all data (for testing or reset)
  async clearAllData(): Promise<void> {
    if (!this.checkDatabaseAvailable()) return;
    const storeNames = [
      "jobs",
      "stockUsage",
      "stockAllocations",
      "clockRecords",
      "safetyChecks",
      "incidentReports",
      "networkAssessments",
    ];
    const transaction = this.db!.transaction(storeNames, "readwrite");

    await Promise.all(
      storeNames.map((storeName) => {
        const store = transaction.objectStore(storeName);
        return store.clear();
      }),
    );
  }
}

export default InternalDatabaseService;
