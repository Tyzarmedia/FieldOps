interface OvertimeSession {
  id: string;
  technicianId: string;
  assistantId?: string;
  workSessionId: string;
  startTime: string;
  endTime?: string;
  totalHours: number;
  jobsCompleted: OvertimeJob[];
  status: "active" | "completed" | "claimed";
  autoGenerated: boolean;
}

interface OvertimeJob {
  jobId: string;
  workOrderNumber: string;
  title: string;
  completedTime: string;
  hoursSpent: number;
  isAfterHours: boolean;
  location: string;
}

interface OvertimeClaim {
  id: string;
  sessionId: string;
  technicianId: string;
  technicianName: string;
  assistantId?: string;
  assistantName?: string;
  overtimeHours: number;
  regularHours: number;
  totalHours: number;
  jobsCompleted: OvertimeJob[];
  claimDate: string;
  status: "pending" | "approved" | "rejected";
  comments: string;
  approvedBy?: string;
  approvalDate?: string;
}

class OvertimeService {
  private readonly REGULAR_HOURS = 8;
  private readonly AFTER_HOURS_START = 17; // 5 PM
  private readonly WEEKEND_DAYS = [0, 6]; // Sunday and Saturday

  /**
   * Track overtime session for technician and assistant
   */
  async startOvertimeTracking(
    technicianId: string,
    assistantId: string | null,
    workSessionId: string
  ): Promise<OvertimeSession> {
    try {
      const response = await fetch('/api/overtime/start-tracking', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${localStorage.getItem('token')}`,
        },
        body: JSON.stringify({
          technicianId,
          assistantId,
          workSessionId,
          startTime: new Date().toISOString(),
          autoGenerated: true,
        }),
      });

      if (!response.ok) {
        throw new Error('Failed to start overtime tracking');
      }

      return await response.json();
    } catch (error) {
      console.error('Error starting overtime tracking:', error);
      throw error;
    }
  }

  /**
   * Check if current work qualifies as overtime
   */
  isOvertimeWork(clockInTime: Date, currentTime: Date = new Date()): boolean {
    const hoursWorked = (currentTime.getTime() - clockInTime.getTime()) / (1000 * 60 * 60);
    const isAfterHours = currentTime.getHours() >= this.AFTER_HOURS_START;
    const isWeekend = this.WEEKEND_DAYS.includes(currentTime.getDay());
    
    return hoursWorked > this.REGULAR_HOURS || isAfterHours || isWeekend;
  }

  /**
   * Get jobs completed during overtime hours
   */
  async getOvertimeJobs(
    sessionId: string,
    startTime: string,
    endTime: string
  ): Promise<OvertimeJob[]> {
    try {
      const response = await fetch(
        `/api/overtime/jobs?sessionId=${sessionId}&start=${startTime}&end=${endTime}`,
        {
          headers: {
            'Authorization': `Bearer ${localStorage.getItem('token')}`,
          },
        }
      );

      if (!response.ok) {
        throw new Error('Failed to get overtime jobs');
      }

      const jobs = await response.json();
      
      // Filter jobs completed after regular hours
      return jobs.filter((job: any) => this.isJobAfterHours(job.completedTime));
    } catch (error) {
      console.error('Error getting overtime jobs:', error);
      return [];
    }
  }

  /**
   * Check if job was completed after regular hours
   */
  private isJobAfterHours(completedTime: string): boolean {
    const completedDate = new Date(completedTime);
    const hour = completedDate.getHours();
    const isWeekend = this.WEEKEND_DAYS.includes(completedDate.getDay());
    
    return hour >= this.AFTER_HOURS_START || isWeekend;
  }

  /**
   * Create overtime claim for technician and assistant
   */
  async createOvertimeClaim(
    sessionId: string,
    technicianId: string,
    assistantId: string | null,
    clockInTime: string,
    clockOutTime: string
  ): Promise<OvertimeClaim[]> {
    try {
      const clockIn = new Date(clockInTime);
      const clockOut = new Date(clockOutTime);
      const totalHours = (clockOut.getTime() - clockIn.getTime()) / (1000 * 60 * 60);
      const overtimeHours = Math.max(0, totalHours - this.REGULAR_HOURS);

      // Get jobs completed during overtime
      const overtimeJobs = await this.getOvertimeJobs(sessionId, clockInTime, clockOutTime);
      
      // Get technician and assistant info
      const [technicianInfo, assistantInfo] = await Promise.all([
        this.getUserInfo(technicianId),
        assistantId ? this.getUserInfo(assistantId) : null,
      ]);

      const claims: OvertimeClaim[] = [];

      // Create claim for technician
      if (overtimeHours > 0 || overtimeJobs.length > 0) {
        const technicianClaim = await this.createClaimRecord({
          sessionId,
          technicianId,
          technicianName: technicianInfo.name,
          assistantId,
          assistantName: assistantInfo?.name,
          overtimeHours,
          regularHours: Math.min(totalHours, this.REGULAR_HOURS),
          totalHours,
          jobsCompleted: overtimeJobs,
          comments: this.generateClaimComments(overtimeJobs, totalHours, "technician"),
        });
        claims.push(technicianClaim);

        // Create claim for assistant if present
        if (assistantId && assistantInfo) {
          const assistantClaim = await this.createClaimRecord({
            sessionId,
            technicianId: assistantId,
            technicianName: assistantInfo.name,
            assistantId: technicianId, // Reference to the main technician
            assistantName: technicianInfo.name,
            overtimeHours,
            regularHours: Math.min(totalHours, this.REGULAR_HOURS),
            totalHours,
            jobsCompleted: overtimeJobs,
            comments: this.generateClaimComments(overtimeJobs, totalHours, "assistant"),
          });
          claims.push(assistantClaim);
        }
      }

      return claims;
    } catch (error) {
      console.error('Error creating overtime claim:', error);
      throw error;
    }
  }

  /**
   * Generate comments for overtime claim
   */
  private generateClaimComments(
    overtimeJobs: OvertimeJob[],
    totalHours: number,
    role: "technician" | "assistant"
  ): string {
    const jobsList = overtimeJobs.map(job => job.workOrderNumber).join(', ');
    const roleText = role === "assistant" ? "as assistant" : "as technician";
    
    let comments = `Overtime claim for ${totalHours.toFixed(2)} hours worked ${roleText}.`;
    
    if (overtimeJobs.length > 0) {
      comments += ` Work orders completed after hours: ${jobsList}.`;
      
      // Add details about each job
      const jobDetails = overtimeJobs.map(job => 
        `${job.workOrderNumber} (${job.title}) - ${job.hoursSpent.toFixed(1)}h at ${job.location}`
      ).join('; ');
      
      comments += ` Job details: ${jobDetails}.`;
    }
    
    comments += ` Automatically generated from work session data.`;
    
    return comments;
  }

  /**
   * Create individual claim record
   */
  private async createClaimRecord(claimData: Omit<OvertimeClaim, 'id' | 'claimDate' | 'status'>): Promise<OvertimeClaim> {
    try {
      const response = await fetch('/api/overtime/claims', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${localStorage.getItem('token')}`,
        },
        body: JSON.stringify({
          ...claimData,
          claimDate: new Date().toISOString(),
          status: 'pending',
        }),
      });

      if (!response.ok) {
        throw new Error('Failed to create overtime claim');
      }

      return await response.json();
    } catch (error) {
      console.error('Error creating claim record:', error);
      throw error;
    }
  }

  /**
   * Get user information
   */
  private async getUserInfo(userId: string): Promise<{ id: string; name: string; role: string }> {
    try {
      const response = await fetch(`/api/users/${userId}`, {
        headers: {
          'Authorization': `Bearer ${localStorage.getItem('token')}`,
        },
      });

      if (!response.ok) {
        throw new Error('Failed to get user info');
      }

      return await response.json();
    } catch (error) {
      console.error('Error getting user info:', error);
      throw error;
    }
  }

  /**
   * Get available assistants for technician selection
   */
  async getAvailableAssistants(technicianWarehouse: string): Promise<any[]> {
    try {
      const response = await fetch(
        `/api/assistants/available?warehouse=${technicianWarehouse}`,
        {
          headers: {
            'Authorization': `Bearer ${localStorage.getItem('token')}`,
          },
        }
      );

      if (!response.ok) {
        throw new Error('Failed to get available assistants');
      }

      const assistants = await response.json();
      
      // Include assistants who have previously worked overtime with technicians
      const assistantsWithHistory = await this.addOvertimeHistory(assistants);
      
      return assistantsWithHistory;
    } catch (error) {
      console.error('Error getting available assistants:', error);
      return [];
    }
  }

  /**
   * Add overtime history to assistants list
   */
  private async addOvertimeHistory(assistants: any[]): Promise<any[]> {
    try {
      const response = await fetch('/api/overtime/assistant-history', {
        headers: {
          'Authorization': `Bearer ${localStorage.getItem('token')}`,
        },
      });

      if (!response.ok) {
        return assistants;
      }

      const history = await response.json();
      
      return assistants.map(assistant => ({
        ...assistant,
        overtimeHistory: history.filter((h: any) => h.assistantId === assistant.id),
        hasOvertimeHistory: history.some((h: any) => h.assistantId === assistant.id),
      }));
    } catch (error) {
      console.error('Error adding overtime history:', error);
      return assistants;
    }
  }

  /**
   * Get overtime claims for review
   */
  async getOvertimeClaims(status?: string): Promise<OvertimeClaim[]> {
    try {
      const queryParams = status ? `?status=${status}` : '';
      const response = await fetch(`/api/overtime/claims${queryParams}`, {
        headers: {
          'Authorization': `Bearer ${localStorage.getItem('token')}`,
        },
      });

      if (!response.ok) {
        throw new Error('Failed to get overtime claims');
      }

      return await response.json();
    } catch (error) {
      console.error('Error getting overtime claims:', error);
      return [];
    }
  }

  /**
   * Approve or reject overtime claim
   */
  async reviewOvertimeClaim(
    claimId: string,
    action: 'approve' | 'reject',
    comments?: string
  ): Promise<void> {
    try {
      const response = await fetch(`/api/overtime/claims/${claimId}/review`, {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${localStorage.getItem('token')}`,
        },
        body: JSON.stringify({
          action,
          comments,
          reviewedBy: localStorage.getItem('userId'),
          reviewDate: new Date().toISOString(),
        }),
      });

      if (!response.ok) {
        throw new Error(`Failed to ${action} overtime claim`);
      }
    } catch (error) {
      console.error(`Error ${action}ing overtime claim:`, error);
      throw error;
    }
  }

  /**
   * Export overtime report
   */
  async exportOvertimeReport(
    startDate: string,
    endDate: string,
    format: 'excel' | 'pdf' = 'excel'
  ): Promise<void> {
    try {
      const response = await fetch(
        `/api/overtime/export?start=${startDate}&end=${endDate}&format=${format}`,
        {
          headers: {
            'Authorization': `Bearer ${localStorage.getItem('token')}`,
          },
        }
      );

      if (!response.ok) {
        throw new Error('Failed to export overtime report');
      }

      const blob = await response.blob();
      const url = window.URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `overtime-report-${startDate}-${endDate}.${format === 'excel' ? 'xlsx' : 'pdf'}`;
      document.body.appendChild(a);
      a.click();
      window.URL.revokeObjectURL(url);
      document.body.removeChild(a);
    } catch (error) {
      console.error('Error exporting overtime report:', error);
      throw error;
    }
  }
}

export const overtimeService = new OvertimeService();
export type { OvertimeSession, OvertimeJob, OvertimeClaim };
